/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2023-09-02 07:48:25.938814
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16;
x0=IKsin(j[0]);
x1=IKcos(j[0]);
x2=IKcos(j[1]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[2]);
x6=IKsin(j[3]);
x7=IKcos(j[3]);
x8=((0.015)*x0);
x9=((0.015)*x5);
x10=((0.095)*x3);
x11=((0.015)*x3);
x12=((0.015)*x1);
x13=(x1*x2);
x14=(x0*x2);
x15=(x2*x5);
x16=((0.095)*x4*x5);
eetrans[0]=((((-1.0)*x0*x16))+(((-0.105)*x0))+(((-1.0)*x12))+(((-0.07)*x14))+(((-1.0)*x10*x14))+((x6*(((((-1.0)*x3*x4*x8))+((x15*x8))))))+((x12*x7)));
eetrans[1]=((0.0225)+(((-1.0)*x8))+((x7*x8))+((x1*x16))+(((0.07)*x13))+((x6*((((x1*x11*x4))+(((-1.0)*x13*x9))))))+((x10*x13))+(((0.105)*x1)));
eetrans[2]=((0.084)+(((-0.095)*x15))+((x6*(((((-1.0)*x11*x2))+(((-1.0)*x4*x9))))))+((x10*x4))+(((0.07)*x4)));
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3, 4}; return freeparams; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j4,cj4,sj4,htj4,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0;  _ij4[0] = -1; _ij4[1] = -1; _nj4 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]);
j4=pfree[1]; cj4=cos(pfree[1]); sj4=sin(pfree[1]);
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=px;
new_py=((-0.0225)+py);
new_pz=((-0.084)+pz);
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j0eval[2];
j0eval[0]=((px*px)+(py*py));
j0eval[1]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
px=0;
py=0;
pp=pz*pz;
j2eval[0]=((40.1111111111111)+(sj3*sj3));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=((1.0)+(((90.702947845805)*(pz*pz))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1, j2]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x17=pz*pz;
CheckValue<IkReal> x20 = IKatan2WithCheck(IkReal(-0.0147),IkReal(((0.14)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x20.valid){
continue;
}
IkReal x18=((1.0)*(x20.value));
if((((0.00021609)+(((0.0196)*x17)))) < -0.00001)
continue;
CheckValue<IkReal> x21=IKPowWithIntegerCheck(IKabs(IKsqrt(((0.00021609)+(((0.0196)*x17))))),-1);
if(!x21.valid){
continue;
}
if( (((-1.0)*(x21.value)*(((-0.0069)+(((-1.0)*x17)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x21.value)*(((-0.0069)+(((-1.0)*x17)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x19=((-1.0)*(IKasin(((-1.0)*(x21.value)*(((-0.0069)+(((-1.0)*x17))))))));
j1array[0]=((((-1.0)*x18))+(((-1.0)*x19)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x18))+(((1.0)*x19)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x22=cj3*cj3;
IkReal x23=pz*pz;
IkReal x24=(cj1*pz);
j2eval[0]=((41.1111111111111)+(((-1.0)*x22)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x22))));
j2eval[2]=((IKabs(((-551.0)+(((190000.0)*x23))+(((-4200.0)*sj3*x24))+(((-441.0)*sj1*sj3)))))+(IKabs(((((-2793.0)*sj1))+(((-26600.0)*x24))+(((87.0)*sj3))+(((-30000.0)*sj3*x23))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x25=cj3*cj3;
IkReal x26=(cj1*sj3);
IkReal x27=((3800.0)*pz);
IkReal x28=((600.0)*pz);
IkReal x29=(sj1*sj3);
j2eval[0]=((41.1111111111111)+(((-1.0)*x25)));
j2eval[1]=((IKabs(((((-1.0)*cj1*x27))+(((63.0)*x26))+(((-399.0)*sj1))+(((42.0)*sj3))+(((-1.0)*x28*x29)))))+(IKabs(((-266.0)+(((-399.0)*cj1))+(((-1.0)*x26*x28))+((sj1*x27))+(((-63.0)*x29))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x25))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x30=pz*pz;
IkReal x31=cj3*cj3;
IkReal x32=(sj1*sj3);
IkReal x33=(cj1*sj3);
IkReal x34=((150.0)*x30);
IkReal x35=((950.0)*x30);
IkReal x36=(sj1*x31);
j2eval[0]=((((-1.0)*x36))+(((41.1111111111111)*sj1)));
j2eval[1]=((IKabs(((-13.965)+(((-1.0)*x32*x34))+(((-1.0)*cj1*x35))+(((-6.555)*cj1))+(((0.435)*x32)))))+(IKabs(((((-2.755)*sj1))+((sj1*x35))+(((-2.205)*sj3))+(((-1.0)*x33*x34))+(((-1.035)*x33))))));
j2eval[2]=IKsign(((((-0.315)*x36))+(((12.95)*sj1))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=0;
cj1=1.0;
j1=0;
IkReal x37=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x37)));
j2eval[1]=((IKabs(((-665.0)+(((-600.0)*pz*sj3)))))+(IKabs(((((-3800.0)*pz))+(((105.0)*sj3))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x37))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=0;
cj1=1.0;
j1=0;
IkReal x38=cj3*cj3;
IkReal x39=pz*pz;
j2eval[0]=((41.1111111111111)+(((-1.0)*x38)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x38))));
j2eval[2]=((IKabs(((-551.0)+(((-4200.0)*pz*sj3))+(((190000.0)*x39)))))+(IKabs(((((-30000.0)*sj3*x39))+(((-26600.0)*pz))+(((87.0)*sj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x40=pz*pz;
CheckValue<IkReal> x41 = IKatan2WithCheck(IkReal(((((-30000.0)*sj3*x40))+(((-26600.0)*pz))+(((87.0)*sj3)))),IkReal(((-551.0)+(((-4200.0)*pz*sj3))+(((190000.0)*x40)))),IKFAST_ATAN2_MAGTHRESH);
if(!x41.valid){
continue;
}
CheckValue<IkReal> x42=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x42.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x41.value)+(((1.5707963267949)*(x42.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x43=IKcos(j2);
IkReal x44=IKsin(j2);
IkReal x45=(sj3*x44);
evalcond[0]=((0.175)+(((0.095)*x43))+(((-0.015)*x45)));
evalcond[1]=((((-0.015)*sj3*x43))+(((-1.0)*pz))+(((-0.095)*x44)));
evalcond[2]=((0.0029)+(((-0.0021)*x45))+(((0.0133)*x43))+(((-1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x46 = IKatan2WithCheck(IkReal(((((-3800.0)*pz))+(((105.0)*sj3)))),IkReal(((-665.0)+(((-600.0)*pz*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x46.valid){
continue;
}
CheckValue<IkReal> x47=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x47.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x46.value)+(((1.5707963267949)*(x47.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x48=IKcos(j2);
IkReal x49=IKsin(j2);
IkReal x50=(sj3*x49);
evalcond[0]=((0.175)+(((-0.015)*x50))+(((0.095)*x48)));
evalcond[1]=((((-0.015)*sj3*x48))+(((-1.0)*pz))+(((-0.095)*x49)));
evalcond[2]=((0.0029)+(((0.0133)*x48))+(((-0.0021)*x50))+(((-1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x51=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x51)));
j2eval[1]=((IKabs(((133.0)+(((600.0)*pz*sj3)))))+(IKabs(((((-21.0)*sj3))+(((3800.0)*pz))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x51))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x52=cj3*cj3;
IkReal x53=pz*pz;
j2eval[0]=((41.1111111111111)+(((-1.0)*x52)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x52))));
j2eval[2]=((IKabs(((-551.0)+(((190000.0)*x53))+(((4200.0)*pz*sj3)))))+(IKabs(((((-30000.0)*sj3*x53))+(((26600.0)*pz))+(((87.0)*sj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x54=pz*pz;
CheckValue<IkReal> x55 = IKatan2WithCheck(IkReal(((((-30000.0)*sj3*x54))+(((26600.0)*pz))+(((87.0)*sj3)))),IkReal(((-551.0)+(((190000.0)*x54))+(((4200.0)*pz*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x55.valid){
continue;
}
CheckValue<IkReal> x56=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x56.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x55.value)+(((1.5707963267949)*(x56.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x57=IKcos(j2);
IkReal x58=IKsin(j2);
IkReal x59=(sj3*x58);
evalcond[0]=((((-0.095)*x58))+pz+(((-0.015)*sj3*x57)));
evalcond[1]=((-0.035)+(((-0.015)*x59))+(((0.095)*x57)));
evalcond[2]=((0.0029)+(((-0.0021)*x59))+(((-1.0)*(pz*pz)))+(((0.0133)*x57)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x60 = IKatan2WithCheck(IkReal(((((-21.0)*sj3))+(((3800.0)*pz)))),IkReal(((133.0)+(((600.0)*pz*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x60.valid){
continue;
}
CheckValue<IkReal> x61=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x61.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x60.value)+(((1.5707963267949)*(x61.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x62=IKcos(j2);
IkReal x63=IKsin(j2);
IkReal x64=(sj3*x63);
evalcond[0]=((((-0.095)*x63))+pz+(((-0.015)*sj3*x62)));
evalcond[1]=((-0.035)+(((0.095)*x62))+(((-0.015)*x64)));
evalcond[2]=((0.0029)+(((-0.0021)*x64))+(((-1.0)*(pz*pz)))+(((0.0133)*x62)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x65=pz*pz;
IkReal x66=(sj1*sj3);
IkReal x67=(cj1*sj3);
IkReal x68=((150.0)*x65);
IkReal x69=((950.0)*x65);
CheckValue<IkReal> x70 = IKatan2WithCheck(IkReal(((-13.965)+(((-1.0)*x66*x68))+(((-1.0)*cj1*x69))+(((0.435)*x66))+(((-6.555)*cj1)))),IkReal(((((-2.755)*sj1))+((sj1*x69))+(((-1.0)*x67*x68))+(((-2.205)*sj3))+(((-1.035)*x67)))),IKFAST_ATAN2_MAGTHRESH);
if(!x70.valid){
continue;
}
CheckValue<IkReal> x71=IKPowWithIntegerCheck(IKsign(((((-0.315)*sj1*(cj3*cj3)))+(((12.95)*sj1)))),-1);
if(!x71.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x70.value)+(((1.5707963267949)*(x71.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x72=IKcos(j2);
IkReal x73=IKsin(j2);
IkReal x74=((0.015)*sj3);
IkReal x75=((1.0)*pz);
IkReal x76=((0.095)*x73);
IkReal x77=(cj1*x72);
IkReal x78=(sj1*x72);
evalcond[0]=((0.0029)+(((-1.0)*pz*x75))+(((-0.0021)*sj3*x73))+(((0.0133)*x72)));
evalcond[1]=((((-1.0)*x76))+(((-1.0)*x72*x74))+(((-0.105)*sj1))+(((-1.0)*cj1*x75)));
evalcond[2]=((0.07)+(((0.105)*cj1))+(((0.095)*x72))+(((-1.0)*sj1*x75))+(((-1.0)*x73*x74)));
evalcond[3]=((((-0.095)*x78))+((sj1*x73*x74))+(((-0.07)*sj1))+pz+((cj1*x76))+((x74*x77)));
evalcond[4]=((0.105)+(((0.07)*cj1))+(((0.095)*x77))+((sj1*x76))+(((-1.0)*cj1*x73*x74))+((x74*x78)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x79=(cj1*sj3);
IkReal x80=((3800.0)*pz);
IkReal x81=((600.0)*pz);
IkReal x82=(sj1*sj3);
CheckValue<IkReal> x83=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x83.valid){
continue;
}
CheckValue<IkReal> x84 = IKatan2WithCheck(IkReal(((((-1.0)*x81*x82))+(((63.0)*x79))+(((-399.0)*sj1))+(((42.0)*sj3))+(((-1.0)*cj1*x80)))),IkReal(((-266.0)+(((-1.0)*x79*x81))+(((-63.0)*x82))+((sj1*x80))+(((-399.0)*cj1)))),IKFAST_ATAN2_MAGTHRESH);
if(!x84.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x83.value)))+(x84.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x85=IKcos(j2);
IkReal x86=IKsin(j2);
IkReal x87=((0.015)*sj3);
IkReal x88=((1.0)*pz);
IkReal x89=((0.095)*x86);
IkReal x90=(cj1*x85);
IkReal x91=(sj1*x85);
evalcond[0]=((0.0029)+(((-0.0021)*sj3*x86))+(((0.0133)*x85))+(((-1.0)*pz*x88)));
evalcond[1]=((((-1.0)*cj1*x88))+(((-0.105)*sj1))+(((-1.0)*x89))+(((-1.0)*x85*x87)));
evalcond[2]=((0.07)+(((0.105)*cj1))+(((-1.0)*sj1*x88))+(((0.095)*x85))+(((-1.0)*x86*x87)));
evalcond[3]=(((x87*x90))+(((-0.07)*sj1))+(((-0.095)*x91))+((sj1*x86*x87))+pz+((cj1*x89)));
evalcond[4]=((0.105)+(((0.07)*cj1))+((x87*x91))+(((0.095)*x90))+((sj1*x89))+(((-1.0)*cj1*x86*x87)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x92=pz*pz;
IkReal x93=(cj1*pz);
CheckValue<IkReal> x94=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x94.valid){
continue;
}
CheckValue<IkReal> x95 = IKatan2WithCheck(IkReal(((((-2793.0)*sj1))+(((-30000.0)*sj3*x92))+(((87.0)*sj3))+(((-26600.0)*x93)))),IkReal(((-551.0)+(((-4200.0)*sj3*x93))+(((-441.0)*sj1*sj3))+(((190000.0)*x92)))),IKFAST_ATAN2_MAGTHRESH);
if(!x95.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x94.value)))+(x95.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x96=IKcos(j2);
IkReal x97=IKsin(j2);
IkReal x98=((0.015)*sj3);
IkReal x99=((1.0)*pz);
IkReal x100=((0.095)*x97);
IkReal x101=(cj1*x96);
IkReal x102=(sj1*x96);
evalcond[0]=((0.0029)+(((-1.0)*pz*x99))+(((-0.0021)*sj3*x97))+(((0.0133)*x96)));
evalcond[1]=((((-1.0)*x100))+(((-0.105)*sj1))+(((-1.0)*cj1*x99))+(((-1.0)*x96*x98)));
evalcond[2]=((0.07)+(((0.105)*cj1))+(((-1.0)*sj1*x99))+(((0.095)*x96))+(((-1.0)*x97*x98)));
evalcond[3]=(((sj1*x97*x98))+((cj1*x100))+((x101*x98))+(((-0.07)*sj1))+pz+(((-0.095)*x102)));
evalcond[4]=((0.105)+(((0.07)*cj1))+((sj1*x100))+(((-1.0)*cj1*x97*x98))+(((0.095)*x101))+((x102*x98)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x105 = IKatan2WithCheck(IkReal(0.0133),IkReal(((-0.0021)*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x105.valid){
continue;
}
IkReal x103=((1.0)*(x105.value));
if((((0.00017689)+(((4.41e-6)*(sj3*sj3))))) < -0.00001)
continue;
CheckValue<IkReal> x106=IKPowWithIntegerCheck(IKabs(IKsqrt(((0.00017689)+(((4.41e-6)*(sj3*sj3)))))),-1);
if(!x106.valid){
continue;
}
if( (((x106.value)*(((0.0029)+(((-1.0)*(pz*pz))))))) < -1-IKFAST_SINCOS_THRESH || (((x106.value)*(((0.0029)+(((-1.0)*(pz*pz))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x104=IKasin(((x106.value)*(((0.0029)+(((-1.0)*(pz*pz)))))));
j2array[0]=((((-1.0)*x103))+(((-1.0)*x104)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x103))+x104);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x107=pz*pz;
IkReal x108=((63.0)*sj3);
IkReal x109=((3800.0)*pz);
IkReal x110=((600.0)*pz*sj3);
j1eval[0]=((1.0)+(((90.702947845805)*x107)));
j1eval[1]=((IKabs(((((2800.0)*pz))+((cj2*x109))+(((-1.0)*cj2*x108))+(((-399.0)*sj2))+(((-1.0)*sj2*x110)))))+(IKabs(((-294.0)+(((-1.0)*sj2*x109))+((sj2*x108))+(((-1.0)*cj2*x110))+(((-399.0)*cj2))))));
j1eval[2]=IKsign(((441.0)+(((40000.0)*x107))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x111=pz*pz;
IkReal x112=(cj2*sj3);
IkReal x113=(pz*sj2);
IkReal x114=(sj2*sj3);
IkReal x115=((150.0)*x111);
IkReal x116=((950.0)*x111);
j1eval[0]=((4.66666666666667)+(((-9.52380952380952)*pz*x112))+(((6.33333333333333)*cj2))+(((-60.3174603174603)*x113))+(((-1.0)*x114)));
j1eval[1]=IKsign(((10.29)+(((-21.0)*pz*x112))+(((-2.205)*x114))+(((13.965)*cj2))+(((-133.0)*x113))));
j1eval[2]=((IKabs(((-4.83)+((x114*x115))+(((-1.0)*cj2*x116))+(((-6.555)*cj2))+(((700.0)*x111))+(((1.035)*x114)))))+(IKabs(((((-1.0)*x112*x115))+(((-1.035)*x112))+(((147.0)*pz))+(((-6.555)*sj2))+(((-1.0)*sj2*x116))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=((1.0)+(((90.702947845805)*(pz*pz))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x117=pz*pz;
IkReal x118=(cj2*sj3);
CheckValue<IkReal> x119=IKPowWithIntegerCheck(((3087.0)+(((280000.0)*x117))),-1);
if(!x119.valid){
continue;
}
CheckValue<IkReal> x120=IKPowWithIntegerCheck(((441.0)+(((40000.0)*x117))),-1);
if(!x120.valid){
continue;
}
if( IKabs(((x119.value)*(((((-2793.0)*sj2))+(((2000000.0)*(pz*pz*pz)))+(((13800.0)*pz))+(((-441.0)*x118)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x120.value)*(((-207.0)+(((-600.0)*pz*x118))+(((-3800.0)*pz*sj2))+(((-30000.0)*x117)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x119.value)*(((((-2793.0)*sj2))+(((2000000.0)*(pz*pz*pz)))+(((13800.0)*pz))+(((-441.0)*x118))))))+IKsqr(((x120.value)*(((-207.0)+(((-600.0)*pz*x118))+(((-3800.0)*pz*sj2))+(((-30000.0)*x117))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x119.value)*(((((-2793.0)*sj2))+(((2000000.0)*(pz*pz*pz)))+(((13800.0)*pz))+(((-441.0)*x118))))), ((x120.value)*(((-207.0)+(((-600.0)*pz*x118))+(((-3800.0)*pz*sj2))+(((-30000.0)*x117))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x121=IKcos(j1);
IkReal x122=IKsin(j1);
IkReal x123=((0.015)*sj3);
IkReal x124=(cj2*x122);
IkReal x125=(pz*x122);
IkReal x126=(cj2*x121);
IkReal x127=(sj2*x122);
IkReal x128=(sj2*x121);
evalcond[0]=((-0.0069)+(((-0.0147)*x121))+(((-1.0)*(pz*pz)))+(((0.14)*x125)));
evalcond[1]=((((-1.0)*cj2*x123))+(((-0.095)*sj2))+(((-1.0)*pz*x121))+(((-0.105)*x122)));
evalcond[2]=((0.07)+(((0.105)*x121))+(((-1.0)*sj2*x123))+(((0.095)*cj2))+(((-1.0)*x125)));
evalcond[3]=((((0.095)*x128))+((x123*x126))+((x123*x127))+pz+(((-0.095)*x124))+(((-0.07)*x122)));
evalcond[4]=((0.105)+(((0.095)*x127))+(((0.095)*x126))+(((-1.0)*x123*x128))+(((0.07)*x121))+((x123*x124)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x129=pz*pz;
IkReal x130=(sj2*sj3);
IkReal x131=(cj2*sj3);
IkReal x132=((950.0)*x129);
IkReal x133=((150.0)*sj3*x129);
CheckValue<IkReal> x134=IKPowWithIntegerCheck(IKsign(((10.29)+(((-21.0)*pz*x131))+(((-2.205)*x130))+(((13.965)*cj2))+(((-133.0)*pz*sj2)))),-1);
if(!x134.valid){
continue;
}
CheckValue<IkReal> x135 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x132))+(((147.0)*pz))+(((-1.035)*x131))+(((-6.555)*sj2))+(((-150.0)*x129*x131)))),IkReal(((-4.83)+(((150.0)*x129*x130))+(((-1.0)*cj2*x132))+(((-6.555)*cj2))+(((1.035)*x130))+(((700.0)*x129)))),IKFAST_ATAN2_MAGTHRESH);
if(!x135.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x134.value)))+(x135.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x136=IKcos(j1);
IkReal x137=IKsin(j1);
IkReal x138=((0.015)*sj3);
IkReal x139=(cj2*x137);
IkReal x140=(pz*x137);
IkReal x141=(cj2*x136);
IkReal x142=(sj2*x137);
IkReal x143=(sj2*x136);
evalcond[0]=((-0.0069)+(((0.14)*x140))+(((-1.0)*(pz*pz)))+(((-0.0147)*x136)));
evalcond[1]=((((-0.105)*x137))+(((-1.0)*cj2*x138))+(((-1.0)*pz*x136))+(((-0.095)*sj2)));
evalcond[2]=((0.07)+(((0.105)*x136))+(((-1.0)*sj2*x138))+(((0.095)*cj2))+(((-1.0)*x140)));
evalcond[3]=((((-0.07)*x137))+((x138*x141))+((x138*x142))+(((0.095)*x143))+pz+(((-0.095)*x139)));
evalcond[4]=((0.105)+((x138*x139))+(((-1.0)*x138*x143))+(((0.095)*x142))+(((0.095)*x141))+(((0.07)*x136)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x144=((63.0)*sj3);
IkReal x145=(pz*sj2);
IkReal x146=((600.0)*sj3);
IkReal x147=(cj2*pz);
CheckValue<IkReal> x148 = IKatan2WithCheck(IkReal(((((2800.0)*pz))+(((-399.0)*sj2))+(((-1.0)*cj2*x144))+(((-1.0)*x145*x146))+(((3800.0)*x147)))),IkReal(((-294.0)+(((-399.0)*cj2))+(((-3800.0)*x145))+(((-1.0)*x146*x147))+((sj2*x144)))),IKFAST_ATAN2_MAGTHRESH);
if(!x148.valid){
continue;
}
CheckValue<IkReal> x149=IKPowWithIntegerCheck(IKsign(((441.0)+(((40000.0)*(pz*pz))))),-1);
if(!x149.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x148.value)+(((1.5707963267949)*(x149.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x150=IKcos(j1);
IkReal x151=IKsin(j1);
IkReal x152=((0.015)*sj3);
IkReal x153=(cj2*x151);
IkReal x154=(pz*x151);
IkReal x155=(cj2*x150);
IkReal x156=(sj2*x151);
IkReal x157=(sj2*x150);
evalcond[0]=((-0.0069)+(((0.14)*x154))+(((-0.0147)*x150))+(((-1.0)*(pz*pz))));
evalcond[1]=((((-0.105)*x151))+(((-1.0)*pz*x150))+(((-1.0)*cj2*x152))+(((-0.095)*sj2)));
evalcond[2]=((0.07)+(((0.095)*cj2))+(((-1.0)*x154))+(((-1.0)*sj2*x152))+(((0.105)*x150)));
evalcond[3]=((((-0.095)*x153))+((x152*x156))+((x152*x155))+(((0.095)*x157))+pz+(((-0.07)*x151)));
evalcond[4]=((0.105)+((x152*x153))+(((0.095)*x155))+(((0.095)*x156))+(((-1.0)*x152*x157))+(((0.07)*x150)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
px=0;
py=0;
pp=pz*pz;
j2eval[0]=((40.1111111111111)+(sj3*sj3));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=((1.0)+(((90.702947845805)*(pz*pz))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1, j2]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x158=pz*pz;
CheckValue<IkReal> x161 = IKatan2WithCheck(IkReal(-0.0147),IkReal(((0.14)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x161.valid){
continue;
}
IkReal x159=((1.0)*(x161.value));
if((((0.00021609)+(((0.0196)*x158)))) < -0.00001)
continue;
CheckValue<IkReal> x162=IKPowWithIntegerCheck(IKabs(IKsqrt(((0.00021609)+(((0.0196)*x158))))),-1);
if(!x162.valid){
continue;
}
if( (((-1.0)*(x162.value)*(((-0.0069)+(((-1.0)*x158)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x162.value)*(((-0.0069)+(((-1.0)*x158)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x160=((-1.0)*(IKasin(((-1.0)*(x162.value)*(((-0.0069)+(((-1.0)*x158))))))));
j1array[0]=((((-1.0)*x159))+(((-1.0)*x160)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x159))+(((1.0)*x160)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x163=cj3*cj3;
IkReal x164=pz*pz;
IkReal x165=(cj1*pz);
j2eval[0]=((41.1111111111111)+(((-1.0)*x163)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x163))));
j2eval[2]=((IKabs(((-551.0)+(((-4200.0)*sj3*x165))+(((190000.0)*x164))+(((-441.0)*sj1*sj3)))))+(IKabs(((((-30000.0)*sj3*x164))+(((-26600.0)*x165))+(((-2793.0)*sj1))+(((87.0)*sj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x166=cj3*cj3;
IkReal x167=(cj1*sj3);
IkReal x168=((3800.0)*pz);
IkReal x169=((600.0)*pz);
IkReal x170=(sj1*sj3);
j2eval[0]=((41.1111111111111)+(((-1.0)*x166)));
j2eval[1]=((IKabs(((-266.0)+((sj1*x168))+(((-399.0)*cj1))+(((-63.0)*x170))+(((-1.0)*x167*x169)))))+(IKabs(((((63.0)*x167))+(((-399.0)*sj1))+(((-1.0)*cj1*x168))+(((42.0)*sj3))+(((-1.0)*x169*x170))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x166))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x171=pz*pz;
IkReal x172=cj3*cj3;
IkReal x173=(sj1*sj3);
IkReal x174=(cj1*sj3);
IkReal x175=((150.0)*x171);
IkReal x176=((950.0)*x171);
IkReal x177=(sj1*x172);
j2eval[0]=((((-1.0)*x177))+(((41.1111111111111)*sj1)));
j2eval[1]=((IKabs(((((-2.755)*sj1))+(((-1.0)*x174*x175))+((sj1*x176))+(((-2.205)*sj3))+(((-1.035)*x174)))))+(IKabs(((-13.965)+(((-6.555)*cj1))+(((0.435)*x173))+(((-1.0)*cj1*x176))+(((-1.0)*x173*x175))))));
j2eval[2]=IKsign(((((-0.315)*x177))+(((12.95)*sj1))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=0;
cj1=1.0;
j1=0;
IkReal x178=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x178)));
j2eval[1]=((IKabs(((-665.0)+(((-600.0)*pz*sj3)))))+(IKabs(((((-3800.0)*pz))+(((105.0)*sj3))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x178))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=0;
cj1=1.0;
j1=0;
IkReal x179=cj3*cj3;
IkReal x180=pz*pz;
j2eval[0]=((41.1111111111111)+(((-1.0)*x179)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x179))));
j2eval[2]=((IKabs(((((-26600.0)*pz))+(((-30000.0)*sj3*x180))+(((87.0)*sj3)))))+(IKabs(((-551.0)+(((190000.0)*x180))+(((-4200.0)*pz*sj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x181=pz*pz;
CheckValue<IkReal> x182=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x182.valid){
continue;
}
CheckValue<IkReal> x183 = IKatan2WithCheck(IkReal(((((-26600.0)*pz))+(((-30000.0)*sj3*x181))+(((87.0)*sj3)))),IkReal(((-551.0)+(((190000.0)*x181))+(((-4200.0)*pz*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x183.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x182.value)))+(x183.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x184=IKcos(j2);
IkReal x185=IKsin(j2);
IkReal x186=(sj3*x185);
evalcond[0]=((0.175)+(((-0.015)*x186))+(((0.095)*x184)));
evalcond[1]=((((-1.0)*pz))+(((-0.015)*sj3*x184))+(((-0.095)*x185)));
evalcond[2]=((0.0029)+(((-0.0021)*x186))+(((0.0133)*x184))+(((-1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x187 = IKatan2WithCheck(IkReal(((((-3800.0)*pz))+(((105.0)*sj3)))),IkReal(((-665.0)+(((-600.0)*pz*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x187.valid){
continue;
}
CheckValue<IkReal> x188=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x188.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x187.value)+(((1.5707963267949)*(x188.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x189=IKcos(j2);
IkReal x190=IKsin(j2);
IkReal x191=(sj3*x190);
evalcond[0]=((0.175)+(((-0.015)*x191))+(((0.095)*x189)));
evalcond[1]=((((-0.095)*x190))+(((-1.0)*pz))+(((-0.015)*sj3*x189)));
evalcond[2]=((0.0029)+(((-0.0021)*x191))+(((0.0133)*x189))+(((-1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x192=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x192)));
j2eval[1]=((IKabs(((133.0)+(((600.0)*pz*sj3)))))+(IKabs(((((-21.0)*sj3))+(((3800.0)*pz))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x192))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x193=cj3*cj3;
IkReal x194=pz*pz;
j2eval[0]=((41.1111111111111)+(((-1.0)*x193)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x193))));
j2eval[2]=((IKabs(((((-30000.0)*sj3*x194))+(((26600.0)*pz))+(((87.0)*sj3)))))+(IKabs(((-551.0)+(((190000.0)*x194))+(((4200.0)*pz*sj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x195=pz*pz;
CheckValue<IkReal> x196=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x196.valid){
continue;
}
CheckValue<IkReal> x197 = IKatan2WithCheck(IkReal(((((-30000.0)*sj3*x195))+(((26600.0)*pz))+(((87.0)*sj3)))),IkReal(((-551.0)+(((190000.0)*x195))+(((4200.0)*pz*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x197.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x196.value)))+(x197.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x198=IKcos(j2);
IkReal x199=IKsin(j2);
IkReal x200=(sj3*x199);
evalcond[0]=((((-0.095)*x199))+pz+(((-0.015)*sj3*x198)));
evalcond[1]=((-0.035)+(((0.095)*x198))+(((-0.015)*x200)));
evalcond[2]=((0.0029)+(((-0.0021)*x200))+(((-1.0)*(pz*pz)))+(((0.0133)*x198)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x201 = IKatan2WithCheck(IkReal(((((-21.0)*sj3))+(((3800.0)*pz)))),IkReal(((133.0)+(((600.0)*pz*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x201.valid){
continue;
}
CheckValue<IkReal> x202=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x202.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x201.value)+(((1.5707963267949)*(x202.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x203=IKcos(j2);
IkReal x204=IKsin(j2);
IkReal x205=(sj3*x204);
evalcond[0]=(pz+(((-0.015)*sj3*x203))+(((-0.095)*x204)));
evalcond[1]=((-0.035)+(((0.095)*x203))+(((-0.015)*x205)));
evalcond[2]=((0.0029)+(((-0.0021)*x205))+(((0.0133)*x203))+(((-1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x206=pz*pz;
IkReal x207=(sj1*sj3);
IkReal x208=(cj1*sj3);
IkReal x209=((150.0)*x206);
IkReal x210=((950.0)*x206);
CheckValue<IkReal> x211=IKPowWithIntegerCheck(IKsign(((((-0.315)*sj1*(cj3*cj3)))+(((12.95)*sj1)))),-1);
if(!x211.valid){
continue;
}
CheckValue<IkReal> x212 = IKatan2WithCheck(IkReal(((-13.965)+(((-1.0)*cj1*x210))+(((-6.555)*cj1))+(((-1.0)*x207*x209))+(((0.435)*x207)))),IkReal(((((-2.755)*sj1))+(((-1.035)*x208))+(((-1.0)*x208*x209))+(((-2.205)*sj3))+((sj1*x210)))),IKFAST_ATAN2_MAGTHRESH);
if(!x212.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x211.value)))+(x212.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x213=IKcos(j2);
IkReal x214=IKsin(j2);
IkReal x215=((0.015)*sj3);
IkReal x216=((1.0)*pz);
IkReal x217=((0.095)*x214);
IkReal x218=(cj1*x213);
IkReal x219=(sj1*x213);
evalcond[0]=((0.0029)+(((0.0133)*x213))+(((-1.0)*pz*x216))+(((-0.0021)*sj3*x214)));
evalcond[1]=((((-1.0)*cj1*x216))+(((-1.0)*x213*x215))+(((-0.105)*sj1))+(((-1.0)*x217)));
evalcond[2]=((0.07)+(((0.105)*cj1))+(((0.095)*x213))+(((-1.0)*sj1*x216))+(((-1.0)*x214*x215)));
evalcond[3]=(((sj1*x214*x215))+(((-0.07)*sj1))+((x215*x218))+(((-0.095)*x219))+pz+((cj1*x217)));
evalcond[4]=((0.105)+(((0.095)*x218))+(((0.07)*cj1))+((x215*x219))+((sj1*x217))+(((-1.0)*cj1*x214*x215)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x220=(cj1*sj3);
IkReal x221=((3800.0)*pz);
IkReal x222=((600.0)*pz);
IkReal x223=(sj1*sj3);
CheckValue<IkReal> x224=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x224.valid){
continue;
}
CheckValue<IkReal> x225 = IKatan2WithCheck(IkReal(((((63.0)*x220))+(((-1.0)*x222*x223))+(((-399.0)*sj1))+(((-1.0)*cj1*x221))+(((42.0)*sj3)))),IkReal(((-266.0)+(((-63.0)*x223))+((sj1*x221))+(((-399.0)*cj1))+(((-1.0)*x220*x222)))),IKFAST_ATAN2_MAGTHRESH);
if(!x225.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x224.value)))+(x225.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x226=IKcos(j2);
IkReal x227=IKsin(j2);
IkReal x228=((0.015)*sj3);
IkReal x229=((1.0)*pz);
IkReal x230=((0.095)*x227);
IkReal x231=(cj1*x226);
IkReal x232=(sj1*x226);
evalcond[0]=((0.0029)+(((-0.0021)*sj3*x227))+(((0.0133)*x226))+(((-1.0)*pz*x229)));
evalcond[1]=((((-1.0)*x230))+(((-1.0)*cj1*x229))+(((-0.105)*sj1))+(((-1.0)*x226*x228)));
evalcond[2]=((0.07)+(((0.105)*cj1))+(((-1.0)*x227*x228))+(((-1.0)*sj1*x229))+(((0.095)*x226)));
evalcond[3]=((((-0.095)*x232))+((cj1*x230))+((x228*x231))+(((-0.07)*sj1))+pz+((sj1*x227*x228)));
evalcond[4]=((0.105)+(((0.07)*cj1))+((sj1*x230))+((x228*x232))+(((0.095)*x231))+(((-1.0)*cj1*x227*x228)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x233=pz*pz;
IkReal x234=(cj1*pz);
CheckValue<IkReal> x235=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x235.valid){
continue;
}
CheckValue<IkReal> x236 = IKatan2WithCheck(IkReal(((((-2793.0)*sj1))+(((-26600.0)*x234))+(((87.0)*sj3))+(((-30000.0)*sj3*x233)))),IkReal(((-551.0)+(((190000.0)*x233))+(((-4200.0)*sj3*x234))+(((-441.0)*sj1*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x236.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x235.value)))+(x236.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x237=IKcos(j2);
IkReal x238=IKsin(j2);
IkReal x239=((0.015)*sj3);
IkReal x240=((1.0)*pz);
IkReal x241=((0.095)*x238);
IkReal x242=(cj1*x237);
IkReal x243=(sj1*x237);
evalcond[0]=((0.0029)+(((-1.0)*pz*x240))+(((0.0133)*x237))+(((-0.0021)*sj3*x238)));
evalcond[1]=((((-1.0)*cj1*x240))+(((-0.105)*sj1))+(((-1.0)*x241))+(((-1.0)*x237*x239)));
evalcond[2]=((0.07)+(((0.105)*cj1))+(((-1.0)*sj1*x240))+(((-1.0)*x238*x239))+(((0.095)*x237)));
evalcond[3]=((((-0.07)*sj1))+((cj1*x241))+((x239*x242))+pz+(((-0.095)*x243))+((sj1*x238*x239)));
evalcond[4]=((0.105)+(((0.07)*cj1))+(((0.095)*x242))+(((-1.0)*cj1*x238*x239))+((x239*x243))+((sj1*x241)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x246 = IKatan2WithCheck(IkReal(0.0133),IkReal(((-0.0021)*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x246.valid){
continue;
}
IkReal x244=((1.0)*(x246.value));
if((((0.00017689)+(((4.41e-6)*(sj3*sj3))))) < -0.00001)
continue;
CheckValue<IkReal> x247=IKPowWithIntegerCheck(IKabs(IKsqrt(((0.00017689)+(((4.41e-6)*(sj3*sj3)))))),-1);
if(!x247.valid){
continue;
}
if( (((x247.value)*(((0.0029)+(((-1.0)*(pz*pz))))))) < -1-IKFAST_SINCOS_THRESH || (((x247.value)*(((0.0029)+(((-1.0)*(pz*pz))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x245=IKasin(((x247.value)*(((0.0029)+(((-1.0)*(pz*pz)))))));
j2array[0]=((((-1.0)*x245))+(((-1.0)*x244)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+x245+(((-1.0)*x244)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x248=pz*pz;
IkReal x249=((63.0)*sj3);
IkReal x250=((3800.0)*pz);
IkReal x251=((600.0)*pz*sj3);
j1eval[0]=((1.0)+(((90.702947845805)*x248)));
j1eval[1]=((IKabs(((((2800.0)*pz))+((cj2*x250))+(((-1.0)*cj2*x249))+(((-399.0)*sj2))+(((-1.0)*sj2*x251)))))+(IKabs(((-294.0)+((sj2*x249))+(((-1.0)*sj2*x250))+(((-399.0)*cj2))+(((-1.0)*cj2*x251))))));
j1eval[2]=IKsign(((441.0)+(((40000.0)*x248))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x252=pz*pz;
IkReal x253=(cj2*sj3);
IkReal x254=(pz*sj2);
IkReal x255=(sj2*sj3);
IkReal x256=((150.0)*x252);
IkReal x257=((950.0)*x252);
j1eval[0]=((4.66666666666667)+(((-60.3174603174603)*x254))+(((-9.52380952380952)*pz*x253))+(((6.33333333333333)*cj2))+(((-1.0)*x255)));
j1eval[1]=IKsign(((10.29)+(((-133.0)*x254))+(((-21.0)*pz*x253))+(((13.965)*cj2))+(((-2.205)*x255))));
j1eval[2]=((IKabs(((-4.83)+(((700.0)*x252))+(((-6.555)*cj2))+(((1.035)*x255))+(((-1.0)*cj2*x257))+((x255*x256)))))+(IKabs(((((-1.035)*x253))+(((147.0)*pz))+(((-1.0)*sj2*x257))+(((-6.555)*sj2))+(((-1.0)*x253*x256))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=((1.0)+(((90.702947845805)*(pz*pz))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x258=pz*pz;
IkReal x259=(cj2*sj3);
CheckValue<IkReal> x260=IKPowWithIntegerCheck(((3087.0)+(((280000.0)*x258))),-1);
if(!x260.valid){
continue;
}
CheckValue<IkReal> x261=IKPowWithIntegerCheck(((441.0)+(((40000.0)*x258))),-1);
if(!x261.valid){
continue;
}
if( IKabs(((x260.value)*(((((-441.0)*x259))+(((-2793.0)*sj2))+(((2000000.0)*(pz*pz*pz)))+(((13800.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x261.value)*(((-207.0)+(((-3800.0)*pz*sj2))+(((-30000.0)*x258))+(((-600.0)*pz*x259)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x260.value)*(((((-441.0)*x259))+(((-2793.0)*sj2))+(((2000000.0)*(pz*pz*pz)))+(((13800.0)*pz))))))+IKsqr(((x261.value)*(((-207.0)+(((-3800.0)*pz*sj2))+(((-30000.0)*x258))+(((-600.0)*pz*x259))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x260.value)*(((((-441.0)*x259))+(((-2793.0)*sj2))+(((2000000.0)*(pz*pz*pz)))+(((13800.0)*pz))))), ((x261.value)*(((-207.0)+(((-3800.0)*pz*sj2))+(((-30000.0)*x258))+(((-600.0)*pz*x259))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x262=IKcos(j1);
IkReal x263=IKsin(j1);
IkReal x264=((0.015)*sj3);
IkReal x265=(cj2*x263);
IkReal x266=(pz*x263);
IkReal x267=(cj2*x262);
IkReal x268=(sj2*x263);
IkReal x269=(sj2*x262);
evalcond[0]=((-0.0069)+(((0.14)*x266))+(((-0.0147)*x262))+(((-1.0)*(pz*pz))));
evalcond[1]=((((-0.105)*x263))+(((-1.0)*pz*x262))+(((-1.0)*cj2*x264))+(((-0.095)*sj2)));
evalcond[2]=((0.07)+(((-1.0)*x266))+(((-1.0)*sj2*x264))+(((0.095)*cj2))+(((0.105)*x262)));
evalcond[3]=((((-0.07)*x263))+(((0.095)*x269))+((x264*x268))+((x264*x267))+pz+(((-0.095)*x265)));
evalcond[4]=((0.105)+(((0.07)*x262))+(((0.095)*x267))+(((0.095)*x268))+((x264*x265))+(((-1.0)*x264*x269)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x270=pz*pz;
IkReal x271=(sj2*sj3);
IkReal x272=(cj2*sj3);
IkReal x273=((950.0)*x270);
IkReal x274=((150.0)*sj3*x270);
CheckValue<IkReal> x275=IKPowWithIntegerCheck(IKsign(((10.29)+(((-2.205)*x271))+(((-21.0)*pz*x272))+(((13.965)*cj2))+(((-133.0)*pz*sj2)))),-1);
if(!x275.valid){
continue;
}
CheckValue<IkReal> x276 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x273))+(((-150.0)*x270*x272))+(((147.0)*pz))+(((-6.555)*sj2))+(((-1.035)*x272)))),IkReal(((-4.83)+(((150.0)*x270*x271))+(((-6.555)*cj2))+(((-1.0)*cj2*x273))+(((700.0)*x270))+(((1.035)*x271)))),IKFAST_ATAN2_MAGTHRESH);
if(!x276.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x275.value)))+(x276.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x277=IKcos(j1);
IkReal x278=IKsin(j1);
IkReal x279=((0.015)*sj3);
IkReal x280=(cj2*x278);
IkReal x281=(pz*x278);
IkReal x282=(cj2*x277);
IkReal x283=(sj2*x278);
IkReal x284=(sj2*x277);
evalcond[0]=((-0.0069)+(((0.14)*x281))+(((-0.0147)*x277))+(((-1.0)*(pz*pz))));
evalcond[1]=((((-0.105)*x278))+(((-1.0)*pz*x277))+(((-1.0)*cj2*x279))+(((-0.095)*sj2)));
evalcond[2]=((0.07)+(((-1.0)*sj2*x279))+(((0.095)*cj2))+(((-1.0)*x281))+(((0.105)*x277)));
evalcond[3]=(((x279*x282))+((x279*x283))+(((-0.07)*x278))+(((0.095)*x284))+(((-0.095)*x280))+pz);
evalcond[4]=((0.105)+(((0.07)*x277))+((x279*x280))+(((0.095)*x282))+(((0.095)*x283))+(((-1.0)*x279*x284)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x285=((63.0)*sj3);
IkReal x286=(pz*sj2);
IkReal x287=((600.0)*sj3);
IkReal x288=(cj2*pz);
CheckValue<IkReal> x289 = IKatan2WithCheck(IkReal(((((2800.0)*pz))+(((-1.0)*cj2*x285))+(((-399.0)*sj2))+(((3800.0)*x288))+(((-1.0)*x286*x287)))),IkReal(((-294.0)+(((-1.0)*x287*x288))+(((-3800.0)*x286))+((sj2*x285))+(((-399.0)*cj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x289.valid){
continue;
}
CheckValue<IkReal> x290=IKPowWithIntegerCheck(IKsign(((441.0)+(((40000.0)*(pz*pz))))),-1);
if(!x290.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x289.value)+(((1.5707963267949)*(x290.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x291=IKcos(j1);
IkReal x292=IKsin(j1);
IkReal x293=((0.015)*sj3);
IkReal x294=(cj2*x292);
IkReal x295=(pz*x292);
IkReal x296=(cj2*x291);
IkReal x297=(sj2*x292);
IkReal x298=(sj2*x291);
evalcond[0]=((-0.0069)+(((-0.0147)*x291))+(((-1.0)*(pz*pz)))+(((0.14)*x295)));
evalcond[1]=((((-0.105)*x292))+(((-1.0)*pz*x291))+(((-1.0)*cj2*x293))+(((-0.095)*sj2)));
evalcond[2]=((0.07)+(((-1.0)*x295))+(((0.105)*x291))+(((0.095)*cj2))+(((-1.0)*sj2*x293)));
evalcond[3]=((((-0.095)*x294))+pz+(((0.095)*x298))+((x293*x297))+((x293*x296))+(((-0.07)*x292)));
evalcond[4]=((0.105)+(((0.07)*x291))+(((-1.0)*x293*x298))+(((0.095)*x297))+(((0.095)*x296))+((x293*x294)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x301 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x301.valid){
continue;
}
IkReal x299=((1.0)*(x301.value));
if((((px*px)+(py*py))) < -0.00001)
continue;
CheckValue<IkReal> x302=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);
if(!x302.valid){
continue;
}
if( (((x302.value)*(((0.015)+(((-0.015)*cj3)))))) < -1-IKFAST_SINCOS_THRESH || (((x302.value)*(((0.015)+(((-0.015)*cj3)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x300=IKasin(((x302.value)*(((0.015)+(((-0.015)*cj3))))));
j0array[0]=((((-1.0)*x299))+(((-1.0)*x300)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x299))+x300);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j2eval[1];
j2eval[0]=((40.1111111111111)+(sj3*sj3));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x303=(cj0*py);
IkReal x304=(px*sj0);
j1eval[0]=((1.0)+(((90.702947845805)*(x304*x304)))+(((-19.047619047619)*x303))+(((90.702947845805)*(x303*x303)))+(((90.702947845805)*(pz*pz)))+(((-181.40589569161)*x303*x304))+(((19.047619047619)*x304)));
j1eval[1]=((IKabs(pz))+(((7.14285714285714)*(IKabs(((-0.0147)+(((0.14)*x303))+(((-0.14)*x304))))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x305=pz*pz;
IkReal x306=(cj0*py);
IkReal x307=(px*sj0);
IkReal x308=((-0.0147)+(((0.14)*x306))+(((-0.14)*x307)));
CheckValue<IkReal> x311 = IKatan2WithCheck(IkReal(x308),IkReal(((0.14)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x311.valid){
continue;
}
IkReal x309=((1.0)*(x311.value));
if((((x308*x308)+(((0.0196)*x305)))) < -0.00001)
continue;
CheckValue<IkReal> x312=IKPowWithIntegerCheck(IKabs(IKsqrt(((x308*x308)+(((0.0196)*x305))))),-1);
if(!x312.valid){
continue;
}
if( (((x312.value)*(((-0.0069)+(((-1.0)*(px*px)))+(((0.21)*x306))+(((-0.03)*cj0*px))+(((-0.21)*x307))+(((-1.0)*x305))+(((-0.03)*py*sj0))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x312.value)*(((-0.0069)+(((-1.0)*(px*px)))+(((0.21)*x306))+(((-0.03)*cj0*px))+(((-0.21)*x307))+(((-1.0)*x305))+(((-0.03)*py*sj0))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x310=IKasin(((x312.value)*(((-0.0069)+(((-1.0)*(px*px)))+(((0.21)*x306))+(((-0.03)*cj0*px))+(((-0.21)*x307))+(((-1.0)*x305))+(((-0.03)*py*sj0))+(((-1.0)*(py*py)))))));
j1array[0]=((((-1.0)*x310))+(((-1.0)*x309)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x310+(((-1.0)*x309)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[2];
IkReal x313=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x313)));
j2eval[1]=IKsign(((370.0)+(((-9.0)*x313))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x314=cj3*cj3;
IkReal x315=(cj1*x314);
j2eval[0]=((((41.1111111111111)*cj1))+(((-1.0)*x315)));
j2eval[1]=IKsign(((((1.85)*cj1))+(((-0.045)*x315))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x316=cj3*cj3;
IkReal x317=(sj1*x316);
j2eval[0]=(x317+(((-41.1111111111111)*sj1)));
j2eval[1]=IKsign(((((-1.85)*sj1))+(((0.045)*x317))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x318=cj3*cj3;
IkReal x319=((600.0)*sj3);
IkReal x320=(px*sj0);
IkReal x321=(cj0*py);
j2eval[0]=((41.1111111111111)+(((-1.0)*x318)));
j2eval[1]=((IKabs(((((-3800.0)*pz))+(((-1.0)*x319*x321))+((x319*x320))+(((105.0)*sj3)))))+(IKabs(((-665.0)+(((-1.0)*pz*x319))+(((3800.0)*x321))+(((-3800.0)*x320))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x318))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=0;
cj1=1.0;
j1=0;
IkReal x322=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x322)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x322))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x323=py*py;
IkReal x324=pz*pz;
IkReal x325=px*px;
IkReal x326=(px*sj0);
IkReal x327=(cj0*py);
IkReal x328=((6300.0)*sj3);
IkReal x329=((30000.0)*sj3);
CheckValue<IkReal> x330=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x330.valid){
continue;
}
CheckValue<IkReal> x331 = IKatan2WithCheck(IkReal(((((-13.5)*cj3*sj3))+((x327*x328))+(((-26600.0)*pz))+(((-1.0)*x326*x328))+(((-1.0)*x325*x329))+(((-1.0)*x323*x329))+(((100.5)*sj3))+(((-1.0)*x324*x329)))),IkReal(((-636.5)+(((85.5)*cj3))+(((-39900.0)*x327))+(((190000.0)*x324))+(((190000.0)*x325))+(((190000.0)*x323))+(((-4200.0)*pz*sj3))+(((39900.0)*x326)))),IKFAST_ATAN2_MAGTHRESH);
if(!x331.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x330.value)))+(x331.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x332=IKcos(j2);
IkReal x333=IKsin(j2);
IkReal x334=(px*sj0);
IkReal x335=(cj0*py);
IkReal x336=(sj3*x333);
evalcond[0]=((((-0.015)*sj3*x332))+(((-1.0)*pz))+(((-0.095)*x333)));
evalcond[1]=((0.175)+(((-0.015)*x336))+(((0.095)*x332))+x334+(((-1.0)*x335)));
evalcond[2]=((0.00335)+(((-1.0)*(px*px)))+(((-0.21)*x334))+(((0.21)*x335))+(((0.0133)*x332))+(((-0.0021)*x336))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x337=((600.0)*sj3);
IkReal x338=(px*sj0);
IkReal x339=(cj0*py);
CheckValue<IkReal> x340 = IKatan2WithCheck(IkReal(((((-1.0)*x337*x339))+(((-3800.0)*pz))+((x337*x338))+(((105.0)*sj3)))),IkReal(((-665.0)+(((-3800.0)*x338))+(((-1.0)*pz*x337))+(((3800.0)*x339)))),IKFAST_ATAN2_MAGTHRESH);
if(!x340.valid){
continue;
}
CheckValue<IkReal> x341=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x341.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x340.value)+(((1.5707963267949)*(x341.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x342=IKcos(j2);
IkReal x343=IKsin(j2);
IkReal x344=(px*sj0);
IkReal x345=(cj0*py);
IkReal x346=(sj3*x343);
evalcond[0]=((((-1.0)*pz))+(((-0.095)*x343))+(((-0.015)*sj3*x342)));
evalcond[1]=((0.175)+(((0.095)*x342))+x344+(((-0.015)*x346))+(((-1.0)*x345)));
evalcond[2]=((0.00335)+(((-1.0)*(px*px)))+(((-0.0021)*x346))+(((-0.21)*x344))+(((-1.0)*(pz*pz)))+(((0.21)*x345))+(((-0.00045)*cj3))+(((-1.0)*(py*py)))+(((0.0133)*x342)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x347=cj3*cj3;
IkReal x348=((600.0)*sj3);
IkReal x349=(px*sj0);
IkReal x350=(cj0*py);
j2eval[0]=((41.1111111111111)+(((-1.0)*x347)));
j2eval[1]=((IKabs(((133.0)+((pz*x348))+(((3800.0)*x349))+(((-3800.0)*x350)))))+(IKabs(((((-1.0)*x348*x349))+(((-21.0)*sj3))+((x348*x350))+(((3800.0)*pz))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x347))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x351=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x351)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x351))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x352=py*py;
IkReal x353=pz*pz;
IkReal x354=px*px;
IkReal x355=(px*sj0);
IkReal x356=(cj0*py);
IkReal x357=((6300.0)*sj3);
IkReal x358=((30000.0)*sj3);
CheckValue<IkReal> x359=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x359.valid){
continue;
}
CheckValue<IkReal> x360 = IKatan2WithCheck(IkReal(((((-13.5)*cj3*sj3))+((x356*x357))+(((26600.0)*pz))+(((100.5)*sj3))+(((-1.0)*x353*x358))+(((-1.0)*x354*x358))+(((-1.0)*x352*x358))+(((-1.0)*x355*x357)))),IkReal(((-636.5)+(((-39900.0)*x356))+(((85.5)*cj3))+(((190000.0)*x352))+(((190000.0)*x353))+(((190000.0)*x354))+(((39900.0)*x355))+(((4200.0)*pz*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x360.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x359.value)))+(x360.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x361=IKcos(j2);
IkReal x362=IKsin(j2);
IkReal x363=(cj0*py);
IkReal x364=(px*sj0);
IkReal x365=(sj3*x362);
evalcond[0]=((((-0.095)*x362))+(((-0.015)*sj3*x361))+pz);
evalcond[1]=((-0.035)+(((-1.0)*x364))+x363+(((0.095)*x361))+(((-0.015)*x365)));
evalcond[2]=((0.00335)+(((0.0133)*x361))+(((-1.0)*(px*px)))+(((-0.0021)*x365))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py)))+(((-0.21)*x364))+(((0.21)*x363)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x366=((600.0)*sj3);
IkReal x367=(px*sj0);
IkReal x368=(cj0*py);
CheckValue<IkReal> x369=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x369.valid){
continue;
}
CheckValue<IkReal> x370 = IKatan2WithCheck(IkReal((((x366*x368))+(((-21.0)*sj3))+(((-1.0)*x366*x367))+(((3800.0)*pz)))),IkReal(((133.0)+(((-3800.0)*x368))+(((3800.0)*x367))+((pz*x366)))),IKFAST_ATAN2_MAGTHRESH);
if(!x370.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x369.value)))+(x370.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x371=IKcos(j2);
IkReal x372=IKsin(j2);
IkReal x373=(cj0*py);
IkReal x374=(px*sj0);
IkReal x375=(sj3*x372);
evalcond[0]=((((-0.095)*x372))+(((-0.015)*sj3*x371))+pz);
evalcond[1]=((-0.035)+(((-1.0)*x374))+(((-0.015)*x375))+x373+(((0.095)*x371)));
evalcond[2]=((0.00335)+(((-1.0)*(px*px)))+(((0.0133)*x371))+(((-0.0021)*x375))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((0.21)*x373))+(((-1.0)*(py*py)))+(((-0.21)*x374)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x376=cj3*cj3;
IkReal x377=((600.0)*sj3);
IkReal x378=(px*sj0);
IkReal x379=(cj0*py);
j2eval[0]=((41.1111111111111)+(((-1.0)*x376)));
j2eval[1]=((IKabs(((-399.0)+(((-3800.0)*x378))+(((3800.0)*x379))+(((42.0)*sj3))+(((-1.0)*pz*x377)))))+(IKabs(((-266.0)+(((-63.0)*sj3))+(((-1.0)*x377*x378))+((x377*x379))+(((3800.0)*pz))))));
j2eval[2]=IKsign(((370.0)+(((-9.0)*x376))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x380=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x380)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x380))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x381=py*py;
IkReal x382=pz*pz;
IkReal x383=px*px;
IkReal x384=(px*sj0);
IkReal x385=(cj0*py);
IkReal x386=((6300.0)*sj3);
IkReal x387=((30000.0)*sj3);
IkReal x388=((4200.0)*sj3);
CheckValue<IkReal> x389 = IKatan2WithCheck(IkReal(((-2793.0)+(((-13.5)*cj3*sj3))+(((-1.0)*x381*x387))+(((26600.0)*x385))+(((-1.0)*x384*x386))+(((100.5)*sj3))+((x385*x386))+(((-26600.0)*x384))+(((-1.0)*x382*x387))+(((-1.0)*x383*x387)))),IkReal(((-636.5)+(((-441.0)*sj3))+(((-39900.0)*x385))+(((85.5)*cj3))+(((-1.0)*x384*x388))+((x385*x388))+(((190000.0)*x382))+(((190000.0)*x383))+(((190000.0)*x381))+(((39900.0)*x384)))),IKFAST_ATAN2_MAGTHRESH);
if(!x389.valid){
continue;
}
CheckValue<IkReal> x390=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x390.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x389.value)+(((1.5707963267949)*(x390.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x391=IKcos(j2);
IkReal x392=IKsin(j2);
IkReal x393=(px*sj0);
IkReal x394=(cj0*py);
IkReal x395=(sj3*x392);
evalcond[0]=((0.07)+(((-1.0)*pz))+(((0.095)*x391))+(((-0.015)*x395)));
evalcond[1]=((-0.105)+(((-1.0)*x393))+(((-0.015)*sj3*x391))+(((-0.095)*x392))+x394);
evalcond[2]=((0.00335)+(((-1.0)*(px*px)))+(((0.0133)*x391))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-0.21)*x393))+(((-1.0)*(py*py)))+(((0.21)*x394))+(((-0.0021)*x395)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x396=((600.0)*sj3);
IkReal x397=(px*sj0);
IkReal x398=(cj0*py);
CheckValue<IkReal> x399 = IKatan2WithCheck(IkReal(((-399.0)+(((-3800.0)*x397))+(((3800.0)*x398))+(((-1.0)*pz*x396))+(((42.0)*sj3)))),IkReal(((-266.0)+(((-63.0)*sj3))+((x396*x398))+(((-1.0)*x396*x397))+(((3800.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x399.valid){
continue;
}
CheckValue<IkReal> x400=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x400.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x399.value)+(((1.5707963267949)*(x400.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x401=IKcos(j2);
IkReal x402=IKsin(j2);
IkReal x403=(px*sj0);
IkReal x404=(cj0*py);
IkReal x405=(sj3*x402);
evalcond[0]=((0.07)+(((-0.015)*x405))+(((0.095)*x401))+(((-1.0)*pz)));
evalcond[1]=((-0.105)+(((-0.095)*x402))+x404+(((-0.015)*sj3*x401))+(((-1.0)*x403)));
evalcond[2]=((0.00335)+(((0.0133)*x401))+(((-1.0)*(px*px)))+(((0.21)*x404))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py)))+(((-0.21)*x403))+(((-0.0021)*x405)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x406=cj3*cj3;
IkReal x407=((600.0)*sj3);
IkReal x408=(cj0*py);
IkReal x409=(px*sj0);
j2eval[0]=((41.1111111111111)+(((-1.0)*x406)));
j2eval[1]=IKsign(((370.0)+(((-9.0)*x406))));
j2eval[2]=((IKabs(((399.0)+((pz*x407))+(((-3800.0)*x408))+(((42.0)*sj3))+(((3800.0)*x409)))))+(IKabs(((-266.0)+((x407*x409))+(((-3800.0)*pz))+(((63.0)*sj3))+(((-1.0)*x407*x408))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x410=cj3*cj3;
j2eval[0]=((41.1111111111111)+(((-1.0)*x410)));
j2eval[1]=IKsign(((2590.0)+(((-63.0)*x410))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x411=py*py;
IkReal x412=pz*pz;
IkReal x413=px*px;
IkReal x414=(px*sj0);
IkReal x415=(cj0*py);
IkReal x416=((6300.0)*sj3);
IkReal x417=((30000.0)*sj3);
IkReal x418=((4200.0)*sj3);
CheckValue<IkReal> x419 = IKatan2WithCheck(IkReal(((2793.0)+(((-13.5)*cj3*sj3))+(((-1.0)*x412*x417))+((x415*x416))+(((100.5)*sj3))+(((26600.0)*x414))+(((-1.0)*x411*x417))+(((-1.0)*x413*x417))+(((-1.0)*x414*x416))+(((-26600.0)*x415)))),IkReal(((-636.5)+(((190000.0)*x412))+(((190000.0)*x413))+(((190000.0)*x411))+(((39900.0)*x414))+(((85.5)*cj3))+((x414*x418))+(((-39900.0)*x415))+(((441.0)*sj3))+(((-1.0)*x415*x418)))),IKFAST_ATAN2_MAGTHRESH);
if(!x419.valid){
continue;
}
CheckValue<IkReal> x420=IKPowWithIntegerCheck(IKsign(((2590.0)+(((-63.0)*(cj3*cj3))))),-1);
if(!x420.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x419.value)+(((1.5707963267949)*(x420.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x421=IKcos(j2);
IkReal x422=IKsin(j2);
IkReal x423=(px*sj0);
IkReal x424=(cj0*py);
IkReal x425=(sj3*x422);
evalcond[0]=((0.07)+(((0.095)*x421))+(((-0.015)*x425))+pz);
evalcond[1]=((0.105)+(((-1.0)*x424))+(((-0.015)*sj3*x421))+x423+(((-0.095)*x422)));
evalcond[2]=((0.00335)+(((-1.0)*(px*px)))+(((0.0133)*x421))+(((-0.21)*x423))+(((-1.0)*(pz*pz)))+(((0.21)*x424))+(((-0.00045)*cj3))+(((-0.0021)*x425))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x426=((600.0)*sj3);
IkReal x427=(px*sj0);
IkReal x428=(cj0*py);
CheckValue<IkReal> x429 = IKatan2WithCheck(IkReal(((399.0)+(((3800.0)*x427))+((pz*x426))+(((-3800.0)*x428))+(((42.0)*sj3)))),IkReal(((-266.0)+((x426*x427))+(((-3800.0)*pz))+(((63.0)*sj3))+(((-1.0)*x426*x428)))),IKFAST_ATAN2_MAGTHRESH);
if(!x429.valid){
continue;
}
CheckValue<IkReal> x430=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x430.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x429.value)+(((1.5707963267949)*(x430.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x431=IKcos(j2);
IkReal x432=IKsin(j2);
IkReal x433=(px*sj0);
IkReal x434=(cj0*py);
IkReal x435=(sj3*x432);
evalcond[0]=((0.07)+(((0.095)*x431))+(((-0.015)*x435))+pz);
evalcond[1]=((0.105)+(((-1.0)*x434))+x433+(((-0.095)*x432))+(((-0.015)*sj3*x431)));
evalcond[2]=((0.00335)+(((-1.0)*(px*px)))+(((-0.21)*x433))+(((0.0133)*x431))+(((-0.0021)*x435))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((0.21)*x434))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x436=cj1*cj1;
IkReal x437=((0.315)*sj3);
IkReal x438=(cj1*sj1);
IkReal x439=(cj0*py);
IkReal x440=((3.0)*sj3);
IkReal x441=((19.0)*pz);
IkReal x442=((19.0)*px*sj0);
IkReal x443=(px*sj0*x440);
CheckValue<IkReal> x444=IKPowWithIntegerCheck(IKsign(((((0.045)*sj1*(cj3*cj3)))+(((-1.85)*sj1)))),-1);
if(!x444.valid){
continue;
}
CheckValue<IkReal> x445 = IKatan2WithCheck(IkReal(((1.995)+(((-1.0)*x437*x438))+(((-1.0)*x438*x443))+(((-1.995)*x436))+(((-19.0)*x439))+((x438*x439*x440))+((pz*x440))+(((-1.0)*x436*x442))+x442+((x438*x441))+(((19.0)*x436*x439))+(((-1.0)*pz*x436*x440))+(((-0.21)*sj1*sj3)))),IkReal(((((-1.0)*x441))+(((1.33)*sj1))+(((1.995)*x438))+((x436*x439*x440))+(((-1.0)*x439*x440))+(((-1.0)*x436*x437))+((pz*x438*x440))+(((-1.0)*x436*x443))+(((-19.0)*x438*x439))+x437+x443+((x438*x442))+((x436*x441)))),IKFAST_ATAN2_MAGTHRESH);
if(!x445.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x444.value)))+(x445.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x446=IKcos(j2);
IkReal x447=IKsin(j2);
IkReal x448=(px*sj0);
IkReal x449=((1.0)*sj1);
IkReal x450=(cj0*py);
IkReal x451=((1.0)*cj1);
IkReal x452=((0.095)*x447);
IkReal x453=(sj3*x447);
IkReal x454=((0.095)*x446);
IkReal x455=((0.015)*sj3*x446);
evalcond[0]=((((-1.0)*x452))+(((-1.0)*x455))+(((-1.0)*pz*x451))+((sj1*x450))+(((-1.0)*x448*x449))+(((-0.105)*sj1)));
evalcond[1]=((0.07)+(((0.105)*cj1))+((cj1*x448))+x454+(((-1.0)*x450*x451))+(((-1.0)*pz*x449))+(((-0.015)*x453)));
evalcond[2]=(((cj1*x455))+((cj1*x452))+(((-0.07)*sj1))+(((-1.0)*sj1*x454))+pz+(((0.015)*sj1*x453)));
evalcond[3]=((0.105)+(((0.07)*cj1))+(((-1.0)*x450))+(((-0.015)*cj1*x453))+((cj1*x454))+x448+((sj1*x452))+((sj1*x455)));
evalcond[4]=((0.00335)+(((-1.0)*(px*px)))+(((-0.21)*x448))+(((0.0133)*x446))+(((-0.0021)*x453))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py)))+(((0.21)*x450)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x456=cj1*cj1;
IkReal x457=((3.0)*sj3);
IkReal x458=(cj1*sj1);
IkReal x459=(px*sj0);
IkReal x460=((0.315)*sj3);
IkReal x461=(cj0*py);
IkReal x462=(pz*x456);
IkReal x463=((19.0)*x456);
CheckValue<IkReal> x464=IKPowWithIntegerCheck(IKsign(((((1.85)*cj1))+(((-0.045)*cj1*(cj3*cj3))))),-1);
if(!x464.valid){
continue;
}
CheckValue<IkReal> x465 = IKatan2WithCheck(IkReal((((x456*x460))+(((-19.0)*x462))+(((-19.0)*x458*x459))+(((0.21)*cj1*sj3))+(((-1.0)*pz*x457*x458))+(((-1.995)*x458))+(((-1.0)*x456*x457*x461))+((x456*x457*x459))+(((19.0)*x458*x461)))),IkReal((((x461*x463))+(((-1.33)*cj1))+(((-1.0)*x459*x463))+(((19.0)*pz*x458))+(((-1.0)*x458*x460))+(((-1.995)*x456))+(((-1.0)*x457*x458*x459))+(((-1.0)*x457*x462))+((x457*x458*x461)))),IKFAST_ATAN2_MAGTHRESH);
if(!x465.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x464.value)))+(x465.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x466=IKcos(j2);
IkReal x467=IKsin(j2);
IkReal x468=(px*sj0);
IkReal x469=((1.0)*sj1);
IkReal x470=(cj0*py);
IkReal x471=((1.0)*cj1);
IkReal x472=((0.095)*x467);
IkReal x473=(sj3*x467);
IkReal x474=((0.095)*x466);
IkReal x475=((0.015)*sj3*x466);
evalcond[0]=((((-1.0)*x475))+(((-1.0)*x472))+(((-1.0)*pz*x471))+(((-1.0)*x468*x469))+((sj1*x470))+(((-0.105)*sj1)));
evalcond[1]=((0.07)+(((0.105)*cj1))+((cj1*x468))+x474+(((-1.0)*pz*x469))+(((-0.015)*x473))+(((-1.0)*x470*x471)));
evalcond[2]=((((-0.07)*sj1))+(((-1.0)*sj1*x474))+((cj1*x475))+((cj1*x472))+(((0.015)*sj1*x473))+pz);
evalcond[3]=((0.105)+(((0.07)*cj1))+(((-0.015)*cj1*x473))+((cj1*x474))+(((-1.0)*x470))+x468+((sj1*x472))+((sj1*x475)));
evalcond[4]=((0.00335)+(((-1.0)*(px*px)))+(((0.21)*x470))+(((0.0133)*x466))+(((-0.0021)*x473))+(((-0.21)*x468))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x476=((600.0)*sj3);
IkReal x477=((63.0)*sj3);
IkReal x478=((3800.0)*sj1);
IkReal x479=(px*sj0);
IkReal x480=(cj1*pz);
IkReal x481=(cj0*py*sj1);
IkReal x482=(cj0*cj1*py);
CheckValue<IkReal> x483 = IKatan2WithCheck(IkReal(((((-1.0)*pz*sj1*x476))+(((-1.0)*x476*x482))+(((-1.0)*x478*x479))+(((-3800.0)*x480))+((cj1*x477))+((cj0*py*x478))+(((-399.0)*sj1))+(((42.0)*sj3))+((cj1*x476*x479)))),IkReal(((-266.0)+(((-1.0)*x476*x480))+((x476*x481))+(((-1.0)*sj1*x477))+(((-3800.0)*cj1*x479))+(((3800.0)*x482))+(((-399.0)*cj1))+((pz*x478))+(((-1.0)*sj1*x476*x479)))),IKFAST_ATAN2_MAGTHRESH);
if(!x483.valid){
continue;
}
CheckValue<IkReal> x484=IKPowWithIntegerCheck(IKsign(((370.0)+(((-9.0)*(cj3*cj3))))),-1);
if(!x484.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x483.value)+(((1.5707963267949)*(x484.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x485=IKcos(j2);
IkReal x486=IKsin(j2);
IkReal x487=(px*sj0);
IkReal x488=((1.0)*sj1);
IkReal x489=(cj0*py);
IkReal x490=((1.0)*cj1);
IkReal x491=((0.095)*x486);
IkReal x492=(sj3*x486);
IkReal x493=((0.095)*x485);
IkReal x494=((0.015)*sj3*x485);
evalcond[0]=((((-1.0)*x491))+(((-1.0)*x494))+((sj1*x489))+(((-1.0)*x487*x488))+(((-0.105)*sj1))+(((-1.0)*pz*x490)));
evalcond[1]=((0.07)+(((0.105)*cj1))+(((-1.0)*pz*x488))+(((-1.0)*x489*x490))+(((-0.015)*x492))+x493+((cj1*x487)));
evalcond[2]=((((0.015)*sj1*x492))+(((-1.0)*sj1*x493))+(((-0.07)*sj1))+pz+((cj1*x491))+((cj1*x494)));
evalcond[3]=((0.105)+(((-0.015)*cj1*x492))+(((0.07)*cj1))+(((-1.0)*x489))+((sj1*x494))+((sj1*x491))+x487+((cj1*x493)));
evalcond[4]=((0.00335)+(((0.0133)*x485))+(((-1.0)*(px*px)))+(((-0.0021)*x492))+(((-0.21)*x487))+(((0.21)*x489))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x497 = IKatan2WithCheck(IkReal(0.0133),IkReal(((-0.0021)*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x497.valid){
continue;
}
IkReal x495=((1.0)*(x497.value));
if((((0.00017689)+(((4.41e-6)*(sj3*sj3))))) < -0.00001)
continue;
CheckValue<IkReal> x498=IKPowWithIntegerCheck(IKabs(IKsqrt(((0.00017689)+(((4.41e-6)*(sj3*sj3)))))),-1);
if(!x498.valid){
continue;
}
if( (((x498.value)*(((0.00335)+(((-1.0)*(px*px)))+(((0.21)*cj0*py))+(((-0.21)*px*sj0))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x498.value)*(((0.00335)+(((-1.0)*(px*px)))+(((0.21)*cj0*py))+(((-0.21)*px*sj0))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x496=IKasin(((x498.value)*(((0.00335)+(((-1.0)*(px*px)))+(((0.21)*cj0*py))+(((-0.21)*px*sj0))+(((-1.0)*(pz*pz)))+(((-0.00045)*cj3))+(((-1.0)*(py*py)))))));
j2array[0]=((((-1.0)*x495))+(((-1.0)*x496)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x495))+x496);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[2];
IkReal x499=cj3*cj3;
IkReal x500=(sj2*sj3);
j1eval[0]=((62.8888888888889)+(((59.1111111111111)*cj2))+(((-1.0)*x499))+(((-9.33333333333333)*x500)));
j1eval[1]=IKsign(((0.01415)+(((-0.000225)*x499))+(((0.0133)*cj2))+(((-0.0021)*x500))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x501=(px*sj0);
IkReal x502=((0.095)*sj2);
IkReal x503=(cj2*pz);
IkReal x504=(cj2*sj3);
IkReal x505=(cj0*py);
IkReal x506=((60.3174603174603)*sj2);
IkReal x507=(pz*sj2*sj3);
j1eval[0]=((((-1.0)*x505*x506))+(((-9.52380952380952)*x504*x505))+(((44.4444444444444)*pz))+((x501*x506))+x504+(((6.33333333333333)*sj2))+(((60.3174603174603)*x503))+(((-9.52380952380952)*x507))+(((9.52380952380952)*x501*x504)));
j1eval[1]=IKsign(((((0.07)*pz))+(((0.095)*x503))+(((-0.015)*x504*x505))+(((-1.0)*x502*x505))+(((0.015)*x501*x504))+((x501*x502))+(((0.001575)*x504))+(((-0.015)*x507))+(((0.009975)*sj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x508=((60.3174603174603)*cj2);
IkReal x509=(px*sj0);
IkReal x510=(cj0*py);
IkReal x511=((0.095)*cj2);
IkReal x512=(pz*sj2);
IkReal x513=(sj2*sj3);
IkReal x514=(cj2*pz*sj3);
IkReal x515=((9.52380952380952)*x513);
j1eval[0]=((-4.66666666666667)+(((44.4444444444444)*x510))+(((-1.0)*x508*x509))+(((60.3174603174603)*x512))+(((-44.4444444444444)*x509))+x513+(((-6.33333333333333)*cj2))+((x508*x510))+(((-1.0)*x510*x515))+(((9.52380952380952)*x514))+((x509*x515)));
j1eval[1]=IKsign(((-0.00735)+(((-0.009975)*cj2))+((x510*x511))+(((0.015)*x509*x513))+(((0.001575)*x513))+(((-0.015)*x510*x513))+(((0.07)*x510))+(((-0.07)*x509))+(((0.015)*x514))+(((0.095)*x512))+(((-1.0)*x509*x511))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x516=cj2*cj2;
IkReal x517=cj3*cj3;
IkReal x518=(sj2*sj3);
IkReal x519=(cj2*sj2);
IkReal x520=(px*sj0);
IkReal x521=(cj0*py);
IkReal x522=(cj2*sj3);
IkReal x523=((0.095)*cj2);
IkReal x524=((0.000225)*x517);
CheckValue<IkReal> x525=IKPowWithIntegerCheck(IKsign(((-0.00735)+(((-0.009975)*cj2))+(((0.095)*pz*sj2))+(((-1.0)*x520*x523))+(((0.001575)*x518))+((x521*x523))+(((0.015)*pz*x522))+(((-0.015)*x518*x521))+(((0.07)*x521))+(((0.015)*x518*x520))+(((-0.07)*x520)))),-1);
if(!x525.valid){
continue;
}
CheckValue<IkReal> x526 = IKatan2WithCheck(IkReal(((((0.0088)*x519))+((pz*x521))+(((0.00285)*sj3*x516))+((x519*x524))+(((-0.001425)*sj3))+(((-1.0)*pz*x520))+(((-0.105)*pz))+(((0.00665)*sj2))+(((0.00105)*x522)))),IkReal(((0.005125)+(((0.0088)*x516))+((x516*x524))+(((-1.0)*x524))+(((-0.00285)*cj2*x518))+(((-0.0021)*x518))+(((-1.0)*(pz*pz)))+(((0.0133)*cj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x526.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x525.value)))+(x526.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x527=IKsin(j1);
IkReal x528=IKcos(j1);
IkReal x529=((0.015)*sj3);
IkReal x530=(px*sj0);
IkReal x531=((0.095)*sj2);
IkReal x532=(cj0*py);
IkReal x533=(cj2*x528);
IkReal x534=(sj2*x527);
IkReal x535=((1.0)*x528);
IkReal x536=(cj2*x527);
IkReal x537=(pz*x527);
IkReal x538=((0.14)*x528);
evalcond[0]=((((-1.0)*cj2*x529))+(((-1.0)*x531))+(((-0.105)*x527))+(((-1.0)*x527*x530))+(((-1.0)*pz*x535))+((x527*x532)));
evalcond[1]=((0.07)+(((-1.0)*x532*x535))+(((-1.0)*sj2*x529))+(((-1.0)*x537))+(((0.105)*x528))+(((0.095)*cj2))+((x528*x530)));
evalcond[2]=((((-0.095)*x536))+pz+(((-0.07)*x527))+((x528*x531))+((x529*x534))+((x529*x533)));
evalcond[3]=((0.105)+(((0.095)*x533))+(((-1.0)*x532))+(((-1.0)*sj2*x528*x529))+x530+(((0.07)*x528))+((x527*x531))+((x529*x536)));
evalcond[4]=((-0.0069)+(((-1.0)*(px*px)))+(((-0.0147)*x528))+(((-0.03)*cj0*px))+(((-1.0)*x530*x538))+(((-1.0)*(pz*pz)))+(((-0.03)*py*sj0))+(((-1.0)*(py*py)))+(((0.21)*x532))+((x532*x538))+(((0.14)*x537))+(((-0.21)*x530)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x539=cj2*cj2;
IkReal x540=cj3*cj3;
IkReal x541=(cj0*py);
IkReal x542=(cj2*sj2);
IkReal x543=(cj2*sj3);
IkReal x544=(px*sj0);
IkReal x545=((0.095)*sj2);
IkReal x546=((0.00285)*sj3);
IkReal x547=((0.000225)*x540);
CheckValue<IkReal> x548=IKPowWithIntegerCheck(IKsign(((((-1.0)*x541*x545))+(((0.07)*pz))+(((0.001575)*x543))+(((-0.015)*x541*x543))+((x544*x545))+(((0.015)*x543*x544))+(((-0.015)*pz*sj2*sj3))+(((0.009975)*sj2))+(((0.095)*cj2*pz)))),-1);
if(!x548.valid){
continue;
}
CheckValue<IkReal> x549 = IKatan2WithCheck(IkReal(((-0.009025)+((x539*x547))+(((-1.0)*x542*x546))+(pz*pz)+(((0.0088)*x539)))),IkReal(((((-0.0088)*x542))+(((-1.0)*x542*x547))+(((-0.00105)*x543))+(((-1.0)*x539*x546))+(((-1.0)*pz*x544))+(((-0.00665)*sj2))+(((-0.105)*pz))+(((0.001425)*sj3))+((pz*x541)))),IKFAST_ATAN2_MAGTHRESH);
if(!x549.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x548.value)))+(x549.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x550=IKsin(j1);
IkReal x551=IKcos(j1);
IkReal x552=((0.015)*sj3);
IkReal x553=(px*sj0);
IkReal x554=((0.095)*sj2);
IkReal x555=(cj0*py);
IkReal x556=(cj2*x551);
IkReal x557=(sj2*x550);
IkReal x558=((1.0)*x551);
IkReal x559=(cj2*x550);
IkReal x560=(pz*x550);
IkReal x561=((0.14)*x551);
evalcond[0]=((((-1.0)*x550*x553))+(((-1.0)*cj2*x552))+(((-1.0)*x554))+(((-0.105)*x550))+((x550*x555))+(((-1.0)*pz*x558)));
evalcond[1]=((0.07)+(((-1.0)*x555*x558))+(((-1.0)*sj2*x552))+(((0.095)*cj2))+(((0.105)*x551))+(((-1.0)*x560))+((x551*x553)));
evalcond[2]=((((-0.095)*x559))+pz+(((-0.07)*x550))+((x551*x554))+((x552*x556))+((x552*x557)));
evalcond[3]=((0.105)+(((-1.0)*x555))+(((0.07)*x551))+x553+((x550*x554))+(((-1.0)*sj2*x551*x552))+((x552*x559))+(((0.095)*x556)));
evalcond[4]=((-0.0069)+(((-1.0)*(px*px)))+(((-0.21)*x553))+(((-0.0147)*x551))+(((-0.03)*cj0*px))+(((0.14)*x560))+(((-1.0)*(pz*pz)))+(((0.21)*x555))+(((-0.03)*py*sj0))+(((-1.0)*(py*py)))+((x555*x561))+(((-1.0)*x553*x561)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x562=(sj2*sj3);
IkReal x563=((0.095)*pz);
IkReal x564=(cj0*py);
IkReal x565=(px*sj0);
IkReal x566=((0.095)*sj2);
IkReal x567=((0.095)*cj2);
IkReal x568=((0.015)*cj2*sj3);
CheckValue<IkReal> x569 = IKatan2WithCheck(IkReal(((((-0.009975)*sj2))+(((0.07)*pz))+((x564*x566))+((x564*x568))+(((-0.001575)*cj2*sj3))+((cj2*x563))+(((-0.015)*pz*x562))+(((-1.0)*x565*x568))+(((-1.0)*x565*x566)))),IkReal(((-0.00735)+(((0.07)*x564))+(((-0.009975)*cj2))+(((0.015)*x562*x565))+(((-0.07)*x565))+((x564*x567))+(((-0.015)*x562*x564))+(((-1.0)*pz*x568))+(((-1.0)*sj2*x563))+(((0.001575)*x562))+(((-1.0)*x565*x567)))),IKFAST_ATAN2_MAGTHRESH);
if(!x569.valid){
continue;
}
CheckValue<IkReal> x570=IKPowWithIntegerCheck(IKsign(((0.01415)+(((-0.0021)*x562))+(((-0.000225)*(cj3*cj3)))+(((0.0133)*cj2)))),-1);
if(!x570.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x569.value)+(((1.5707963267949)*(x570.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x571=IKsin(j1);
IkReal x572=IKcos(j1);
IkReal x573=((0.015)*sj3);
IkReal x574=(px*sj0);
IkReal x575=((0.095)*sj2);
IkReal x576=(cj0*py);
IkReal x577=(cj2*x572);
IkReal x578=(sj2*x571);
IkReal x579=((1.0)*x572);
IkReal x580=(cj2*x571);
IkReal x581=(pz*x571);
IkReal x582=((0.14)*x572);
evalcond[0]=(((x571*x576))+(((-1.0)*cj2*x573))+(((-1.0)*x571*x574))+(((-0.105)*x571))+(((-1.0)*x575))+(((-1.0)*pz*x579)));
evalcond[1]=((0.07)+(((-1.0)*x581))+(((-1.0)*sj2*x573))+(((-1.0)*x576*x579))+(((0.095)*cj2))+(((0.105)*x572))+((x572*x574)));
evalcond[2]=((((-0.07)*x571))+(((-0.095)*x580))+((x573*x577))+((x573*x578))+pz+((x572*x575)));
evalcond[3]=((0.105)+(((0.095)*x577))+((x571*x575))+(((-1.0)*sj2*x572*x573))+(((0.07)*x572))+(((-1.0)*x576))+((x573*x580))+x574);
evalcond[4]=((-0.0069)+(((-1.0)*(px*px)))+(((0.21)*x576))+(((-0.0147)*x572))+(((-0.21)*x574))+(((-0.03)*cj0*px))+(((-1.0)*(pz*pz)))+(((-1.0)*x574*x582))+(((0.14)*x581))+(((-0.03)*py*sj0))+((x576*x582))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "813d39e26ac8e2795075b66f0c3d0959"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
